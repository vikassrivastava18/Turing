# -*- coding: utf-8 -*-
"""Python-Dsa.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lTnHxgnM5DFLGqPD4i_IZVc-xf-Dep4o

Find whether a number is a prime
"""

def is_prime(n: int) -> str:
    """
    Parameters: integer
    Returns: A string saying whether input is a prime
    Plan: Use Python modulus function to check if the iput divides numbers coming before it.
    """
    if n < 2:
        return 'Prime number starts from 2'
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return f'Not prime, divided by {i}'
    return 'Is prime'

for i in range(100):
  print(i, is_prime(i))


# O(n) = (int(n ** 0.5)) = n ** 0.5

"""Random code for error handling"""
def remainder(a: int, b: int) -> (int | AssertionError):
    """
    Parameters: two integers
    Returns: Returns integer remainder for correct input, Assertion Error
    Plan: Use assertion concept for input validation
    """
    assert  b!=0, 'Denominator should not be 0'
    assert type(a) == int and type(b) == int, "Invalid inputs"

    r = a % b
    return r
print("Remainder:--------------------------------")
print(remainder(5, 2))
remainder(6, 2)
remainder(5, 0)
remainder(5, "2")


"""Recursion to find last element of a list."""
def last_recursion(ls: list) -> any | str:
  if len(ls) == 0:
    return "Empty list"
  elif len(ls[1:]) == 0:
    return ls[0]
  else:
    return last_recursion(ls[1:])

print(last_recursion([1,2,3]))
print(last_recursion([]))
print(last_recursion([1]))


"""Returns sum of all chars that are digits"""
def sum_digits(s: str) -> int:
  assert len(s) != 0, "s is empty"
  total = 0
  for char in s:
    try:
      val = int(char)
      total += val
    except:
      raise ValueError("string contained a character")
  return total

print(sum_digits("12345"))

sum_digits("abcd")

try:
  a = int(input("Tell me one number: "))
  b = int(input("Tell me another number: "))
  print("a/b = ", a/b)
  print("a+b = ", a+b)
except ValueError:
  print("Could not convert to a number.")
except ZeroDivisionError:
  print("Can't divide by zero")
  print("a/b = infinity")
  print("a+b =", a+b)
except:
  print("Something went very wrong.")
finally:
  print("Program executed")

test_grades = [[['peter', 'parker'], [80.0, 70.0, 85.0]],
              [['bruce', 'wayne'], [100.0, 80.0, 74.0]]]
# output [[['peter', 'parker'], [80.0, 70.0, 85.0], 78.33],
#         [['bruce', 'wayne'], [100.0, 80.0, 74.0], 84.66]
#         ]
# Add a student who didn't appear in exam
# [['deadpool'], []]]

get_average = lambda ls: sum(ls)/len(ls)

for student in test_grades:
  name, grades = student
  total = sum(grades)
  avg = get_average(grades)
  student.append(avg)
print(test_grades)

def avg(grades: list[int]) -> (int | None):
  try:
    return sum(grades)/len(grades)
  except ZeroDivisionError:
    print('warning: no grades data')
    return None

def print_even_indexs(word: str) -> list:
    return word[::2]

print_even_indexs("abcdefg")

import random
import time

def guess_with_binary(n: int) -> tuple[int, int]:
    """
    Params:  A number to guess
    Returns: The guessed number, number of attempts
    """
    start_time = time.time()

    num = random.randint(0, n)
    print("Number to guess: ", num)

    start, end = 0, n
    guess = (start + end) // 2
    count = 0
    print(f"Guess: {guess}, Count: {count}")

    while not guess == num:
        if num > guess:
            start = guess
        else:
            end = guess
        guess = (start + end) // 2
        count += 1
        print(f"Guess: {guess}, Count: {count}")

    end_time = time.time()
    print("Total time: ", end_time - start_time)
    return num, count

guess_with_binary(100000000000000)

def evaluate_quadratic(a) -> (float | int):
    return a * x * x + b * x + c

evaluate_quadratic(1,1,1,1)

def two_quadratics(a1: (float | int), b1: (float | int), c1: (float | int), x1: (float | int), a2: (float | int), b2: (float | int), c2: (float | int), x2: (float | int)) -> (float | int):
    return (a1 * x1 ** 2 + b1 * x1 + c1) + (a1 * x2 ** 2 + b2 * x2 + c2)

two_quadratics(1,1,1,1,1,1,1,1)

def same_chars(w1: str, w2: str) -> bool:
    """
    Parameters: Two strings
    Returns: True if the two strings have same characters, else False
    Plan: Use concept of Sets for sameness.
    """
    w1_formatted, w2_formatted = list(set(w1)), list(set(w2))

    if not len(w1_formatted) == len(w2_formatted):
        return False

    for char in w1_formatted:
        if not char in w2_formatted:
            return False

    return True

print(same_chars("abc", "cab"))     # prints True
print(same_chars("abccc", "caaab")) # prints True
print(same_chars("abcd", "cabaa"))  # prints False
print(same_chars("abcabc", "cabz")) # prints False

def dot_product(tA: tuple[int | float], tB: tuple[int | float]):
    """
    tA: a tuple of numbers
    tB: a tuple of numbers of the same length as tA
    Assumes tA and tB are the same length.
    Returns a tuple where the:
    * first element is the length of one of the tuples
    * second element is the sum of the pairwise products of tA and tB
    """
    _sum = 0

    for i in range(len(tA)):
        _sum += tA[i] * tB[i]

    return (len(tA), _sum)

# Examples:
tA = (1, 2, 3)
tB = (4, 5, 6)
print(dot_product(tA, tB)) # prints (3,32)

def remove_and_sort(Lin: list[int], k: int) -> None:
    """ 
    Mutates Lin to remove the first k elements in Lin and
    then sorts the remaining elements in ascending order.
    If you run out of items to remove, Lin is mutated to an empty list.
    Does not return anything.
    """
    # Your code here
    global L
    L = Lin[k:]
    L.sort()

# Examples:
L = [1,6,3,5,7, 0]
k = 2
remove_and_sort(L, k)
print(L)   # prints the list [3, 6]

def count_sqrts(nums_list: list[int]) -> int:
    """
    nums_list: a list
    Assumes that nums_list only contains positive numbers and that there are no duplicates.
    Returns how many elements in nums_list are exact squares of elements in the same list, including itself.
    """
    # Your code here
    count = 0

    for item in nums_list:
        if item ** 2 in nums_list:
            count +=1

    return count

# Examples:
print(count_sqrts([3,4,2,1,9,25])) # prints 3

def check_brackets(chars: str) -> bool:
    """
    Parameters: A string of characters
    Returns: True if all the brackets are closed in expected order
    Plan: Create a bucket for open brackets.
          When a new closed bracket is encountered match with last bracket in bucket.
    """
    bucket = []
    open_brackets = ["{", "[", "("]
    closed_brackets = ["}", "]", ")"]

    for char in chars:
        if char in open_brackets:
            bucket.append(char)
        elif char in closed_brackets:
            if len(bucket) == 0:
                return False

            last_open = bucket[-1]
            index = open_brackets.index(last_open)

            if not closed_brackets.index(char) == index:
                return False
            else:
                bucket = bucket[:-1]

    return len(bucket) == 0

print(check_brackets("{hello[])}"))
print(check_brackets("{hello[]}"))
print(check_brackets("{(hello[])}]"))
print(check_brackets("{[({[()]})]}"))

[1,2,3][:-1]

def max_sum_subarray(l: list[int|float], k: int) -> int:
    """
    Parameters: l -> list of numbers
                k -> size of subarray
    Returns:    maximum possible sum for subarray of size k
    """
    max_sum = sum(l[:k])

    for i in range(1, len(l)-k+1):
        new_sum = sum(l[i:i+k])
        max_sum = max(new_sum, max_sum)
    return max_sum

rand_list = [random.randint(1,1000) for i in range(100000000)]

import time, random

start_time = time.time()

# rand_list = [random.randint(1,1000) for i in range(100000000)]
max_sum_subarray(rand_list, 5)

end_time = time.time()

print("Total time: ", end_time - start_time)

def max_subarray_optimal(l: list, k: int) -> int:
    """
    Parameters: l -> list of numbers
                k -> size of subarray
    Returns the maximum possible sum for subarray of size k
    """

    if len(l) < k:
        return None  # or raise an error if desired

    curr_sum = sum(l[:k])
    max_sum = curr_sum

    for i in range(k, len(l)):
        curr_sum += l[i] - l[i - k]  # slide window forward
        max_sum = max(max_sum, curr_sum)

    return max_sum

import time, random
start_time = time.time()

# rand_list = [random.randint(1,1000) for i in range(100000000)]
max_subarray_optimal(rand_list, 5)

end_time = time.time()

print("Total time: ", end_time - start_time)

def longest_possible_substring_count(word):
    """
        Returns the longest sbstring in the word
    """
    count = 0
    output = {}
    start = 0
    end = 0

    for i in range(1, len(word)):
        end += 1

        substring = word[start: end]

        if not len(set(substring)) == len(substring):
            output[substring[:-1]] = len(substring)-1
            start = end-1
    output[word[start:]] = len(word[start:])

    return output

longest_possible_substring_count("abcadcbe")

def longest_unique_substring_length(s):
    seen = set()
    left = 0

    max_length = 0

    for right in range(len(s)):
        # If character is already in the current window, shrink from the left
        while s[right] in seen:
            seen.remove(s[left])
            left += 1

        seen.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length

longest_unique_substring_length("abcadcbb")

def two_sum(l, s):
    """
        Return a pair of indexes of elements in list l that sum to s
        Sliding windows concept used
    """
    left = 0
    right = len(l) - 1

    while left < right:
        if l[left] + l[right] == s:
            return (left, right)

        elif l[left] + l[right] < s:
            left += 1

        else:
            right -= 1

    return None

numbers = [1, 3, 4, 6, 8, 11]
target = 10
two_sum(numbers, target)

numbers = [random.randint(1,100000) for i in range(100000)]
numbers.sort()
target = random.randint(0,10000)
print("Target: ", target)
two_sum(numbers, target)

def three_sum(l: list, s:int=0) -> list:
    """
        Returns a triplet whose sum = s
        Using sliding windows technique
    """
    result = []
    l.sort()

    for third in range(0, len(l)-2):
        left = third + 1
        right = len(l) - 1

        while left < right:
            if l[third] + l[right] + l[left] == s:
                result.append([l[third], l[left], l[right]])
                left += 1
                right -= 1

            elif l[third] + l[right] + l[left] < s:
                left += 1
            else:
                right -=1

    return result

import random

for i in range(5):
    numbers = [random.randint(1,10) for i in range(10)]
    print("Numbers: ", numbers)
    target = random.randint(0,15)
    print("Target: ", target)

    result = three_sum(numbers, target)
    print("Result: ", result)
    print("-----------------------")

from collections import Counter

def is_anagram2(w1: str, w2:str) -> bool:
    print("Count: ",Counter(w1))
    return Counter(w1) == Counter(w2)

def is_anagram3(w1, w2):
    return sorted(w1) == sorted(w2)

print(is_anagram2("aab", "abb"))
# print(is_anagram3("aab", "abb"))

def sum_str_lengths(L):
    """
    L is a non-empty list containing either:
    * string elements or
    * a non-empty sublist of string elements
    Returns the sum of the length of all strings in L and
    lengths of strings in the sublists of L. If L contains an
    element that is not a string or a list, or L's sublists
    contain an element that is not a string, raise a ValueError.
    """
    # Your code here
    result = 0

    for item in L:
        if isinstance(item, str):
            result += len(item)
        elif isinstance(item, list):
            result += sum_str_lengths(item)

        else:
            raise ValueError("Invalid input")
    return result

# Examples:
print(sum_str_lengths(["abcd", "e", "fg", ["abcd", ["e", "fg"]]]))

def flatten(L):
    """
    L: a list
    Returns a copy of L, which is a flattened version of L
    """
    # Your code here
    result = []

    for item in L:
        if isinstance(item, int):
            result.append(item)
        else:
            result += flatten(item)

    return result

# Examples:
L = [[1,4,[6],2],[[[3]],2],4,5]
print(flatten(L)) # prints the list [1,4,6,2,3,2,4,5]

class Circle():
    def __init__(self, radius):
        """ Initializes self with radius """
        # your code here
        self.radius = radius

    def get_radius(self):
        """ Returns the radius of self """
        # your code here
        return self.radius

    def set_radius(self, radius):
        """ radius is a number
        Changes the radius of self to radius """
        # your code here
        self.radius = radius

    def get_area(self):
        """ Returns the area of self using pi = 3.14 """
        # your code here
        return self.radius ** 2

    def equal(self, c):
        """ c is a Circle object
        Returns True if self and c have the same radius value """
        # your code here
        return self.radius == c.radius

    def bigger(self, c):
        """ c is a Circle object
        Returns self or c, the Circle object with the bigger radius """
        # your code here
        if self.radius > c.radius:
            return self
        return c

class Circle():
    def __init__(self, radius):
        """ Initializes self with radius """
        self.radius = radius

    def get_radius(self):
        """ Returns the radius of self """
        return self.radius

    def __add__(self, c):
        """ c is a Circle object
        Returns a new Circle object whose radius is
        the sum of self and c's radius """
        c = Circle(self.radius + c.radius)
        return c

    def __str__(self):
        """ A Circle's string representation is the radius """
        return f"Circle of radius: {self.radius}"

class Container(object):
    """
    A container object is a list and can store elements of any type
    """
    def __init__(self):
        """
        Initializes an empty list
        """
        self.myList = []

    def size(self):
        """
        Returns the length of the container list
        """
        return len(self.myList)

    def add(self, elem):
        """
        Adds the elem to one end of the container list, keeping the end
        you add to consistent. Does not return anything
        """
        self.myList.append(elem)

class Queue(Container):
    """
    A subclass of Container. Has an additional method to remove elements.
    """
    def remove(self):
        """
        The oldest element in the container list is removed
        Returns the element removed or None if the stack contains no elements
        """
        if len(self.myList) == 0:
            return None

        return self.myList.pop(0)

def fibonacci(n):
    result = {0: 0, 1: 1}

    if n < 2:
        return result[n]

    for i in range(2, n+1):
        result[i] = result[i-1] + result[i-2]

    return result[n]

for i in range(0,10):
    print(fibonacci(i))

def fibonacci_optimal(n):
    # Optimizes memory space
    if n == 0:
        return 0
    a, b = 0, 1

    for i in range(2, n+1):
        a, b = b, a + b

    return b

for i in range(0,10):
    print(fibonacci_optimal(i))

from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

fibonacci(10)

def fibonacci(n, memo={0:0, 1:1}):
    if n in memo:
        return memo[n]
    memo[n] =  fibonacci(n-1, memo) + fibonacci(n-2, memo)

    return memo[n]

def group_anagram(words):
    result = {}

    for word in words:
        w1_sorted = ''.join(sorted(word))
        if w1_sorted not in result:
            result[w1_sorted] = [word]
        else:
            result[w1_sorted].append(word)

    return list(result.values())

group_anagram(["eat", "tea", "ate", "pan", "nap"])

print(sorted("word"))

def encoded_string(string):
    # "3[a]2[bc]5[a]","13[a]2[bc]5[a]", 2[abc3[de]]
    result = ""
    counter = 0

    while counter < len(string):
        i=0
        digit_str = ""
        while True:
            try:
                digit = int(string[counter+i])
                digit_str += str(digit)
                i += 1
            except Exception as e:
                break
            finally:
                digit = int(digit_str)
        s, e = string.find("[", counter), string.find("]", counter)
        inter_string = string[s+1:e]
        result += inter_string * digit

        counter = e+1

    return result

encoded_string("13[a]10[bc]")

"3[a]2[bc]".find("]", 4)

def generate_subsets(nums):
    result = []

    def backtrack(index, path):
        # Add the current subset to the result
        result.append(path[:])  # Copy to avoid mutation

        # Try including each element one by one
        for i in range(index, len(nums)):
            path.append(nums[i])             # Choose
            print("Path: ", path)
            backtrack(i + 1, path)           # Explore
            path.pop()                       # Un-choose (backtrack)

    backtrack(0, [])
    return result

l = [1,2]
generate_subsets(l)

path =[1,2,3]
path.pop()
path


# Valid anagram
def valid_anagram(a: str, b: str):
    return sorted(a) == sorted(b)

print(valid_anagram("aab", "baa"))
print(valid_anagram("papa", "appa"))
print(valid_anagram("aab", "bba"))

students = []

with open("names.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        students.append({"name": name, "house": house})
        
students = sorted(students, key=lambda student: (student["name"], student["house"]))

print("Result: ", students)